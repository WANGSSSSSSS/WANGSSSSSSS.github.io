---
title: 异常控制流（一）
date: 2021-03-28 16:28:53
tags:
- os
- cs
categories:
- os
---

### 异常控制流（一）

### 非本地跳转

c语言提供了用户级别的异常控制流形式，成为非本地跳转。这个机制可以实现从一个函数直接转移到另一个函数，而不是遵循基本的调用过程（参数压戰+call function）。非本地跳转机制主要通过setjump函数和longjump函数实现。

```c
#include <setjmp.h>
int setjmp(jmp_buf env);
int sigsetjmp(sigjmp_buf env, int savesigs);

// 返回：setjmp 返回 0，longjmp 返回非零。
```

#### 函数 setjump

setjump 函数的作用相当于保存复活点，因此函数参数为一个缓冲区，作用就是将环境信息保存起来，这个信息包括pc，栈指针以及一些通用的寄存器（rax，rbx，rdi..）

```c
jmp_buf env;

int main()
{
    rc = setjmp(env); 
}
```

#### 函数 longjump

longjump实现从刚才保存的复活点重新启动，然后触发一个setjump调用的返回

```c
jmp_buf env;

int main()
{
    rc = setjmp(env); 
    longjump(env, 0);
}
```

这里有一些奇怪的东西：

* setjump多次返回：调用一次，longjump调用又从那里返回一次
* setjump返回值：第一次调用返回0，longjump调用返回的时候返回值是savesigs，这个数字被用来解码，至于原因，后文会说
* longjump不返回

这里根据我对signal机制的了解，大概实现思路已经有了

### 非本地跳转应用

#### 高性能异常处理

直接随地跳转，如果是在递归过程中间出现了异常，大量的递归栈要被解开，会浪费大量时间，通过非本地跳转可以实现快速上报错误，返回值指定了错误码，用户可以用来制定解码规则，甄别错误类型。

**高级语言的异常处理**

C++ 和 Java 提供的异常机制是较高层次的，是 C 语言的 setjmp 和 longjmp 函数的更加结构化的版本。你可以把 try 语句中的 catch 子句看做类似于 setjmp 函数。相似地，throw 语句就类似于 longjmp 函数。

### 非本地跳转实验

我只是简单的复制粘贴了书上的代码，这个东西挺好玩的，不过我懒得写了。

```c
#include <stdio.h>
#include <setjmp.h>
#include <stdlib.h>


jmp_buf buf;

int error1 = 0;
int error2 = 1;

void foo(void), bar(void);

int main()
{
    switch (setjmp(buf)) {
    case 0:
        foo();
        break;
    case 1:
        printf("Detected an error1 condition in foo\n");
        break;
    case 2:
        printf("Detected an error2 condition in foo\n");
        break;
    default:
        printf("Unknown error condition in foo\n");
    }
    exit(0);
}

/* Deeply nested function foo */
void foo(void)
{
    if (error1)
        longjmp(buf, 1);
    bar();
}

void bar(void)
{
    if (error2)
        longjmp(buf, 2);
}
```

##### 实验结果：

![](/images/image-20210328171319221.png)

### 非本地跳转实现原理

#### 基本数据结构与函数定义

<img src="/images/image-20210328171757424.png" alt="image-20210328171757424" style="zoom: 67%;" />

jmp buf是一个jmp buf tag的指针，这种定义方式还挺奇怪的，以前没见过

**__jmpbuf**   : 一个int数组 int[8]

**__sigset_t** : 老熟人了，大致已经猜到底层就是signal那套机制了

<img src="/images/image-20210328172313775.png" alt="image-20210328172313775" style="zoom:80%;" />

##### setjump 函数

<img src="/images/image-20210328171704299.png" alt="image-20210328171704299" style="zoom: 67%;" />

##### longjump函数

<img src="/images/image-20210328172518149.png" alt="image-20210328172518149" style="zoom:80%;" />

#### 实现原理梳理：

##### setjump系统调用发生：

现在处于内核里面了，寄存器按照x86的32位描述，这块应该没啥问题，很好理解

上面是用户栈，下面是内核栈，最下面是寄存器状态

![image-20210328173109840](/images/image-20210328173109840.png)

##### set过程：

1. 根据系统调用传入的参数，在用户栈中找到env：env（这是一个指针其实，前面数据结构有提到），将寄存器保存下来，（那八大金刚寄存器），从前面的数据结构可以看出，有字长设置，自己实现需要注意这个问题
2. 退出，这是第一次调用返回，也是最正常的一次

![image-20210328173412838](/images/image-20210328173412838.png)

#### longjump过程：

1. 根据参数找到保存寄存器的地方，恢复寄存器到核心栈

   注意：这里比signal简单一点，不需要存上下文，因为是直接返回

2. 恢复之后，内核栈里面保存的上下文变成了esp指向了set的时候的状态，eip指向了返回地址

3. 修改返回值：根据第三个参数，修改eax

4. 退出，这个时候操作系统根据tss寄存器找到上下文，恢复好寄存器，然后第二次返回setjump

![image-20210328174109255](/images/image-20210328174109255.png)

### 结语

这个过程其实很简单，比signal简单多了，因为是一个进程自己搞自己，不牵扯页表切换，就这样吧

​																												我是王帅，一个西工大的本科屌丝